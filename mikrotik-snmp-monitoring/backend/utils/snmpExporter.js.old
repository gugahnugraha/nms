/**
 * SNMP Exporter - Collects and exports SNMP metrics in a standardized format
 * Inspired by Prometheus SNMP exporter but adapted for MERN application
 * 
 * Enhanced implementation for integration with React frontend and MongoDB
 * 
 * Features:
 * - Basic SNMP operations (createSession, get, walk)
 * - MikroTik-specific data collection (system info, resources, interfaces, storage)
 * - Scheduled metrics collection with configurable intervals
 * - Real-time metrics for frontend dashboards
 * - Performance optimized for React integration
 */

const snmp = require('net-snmp');
const EventEmitter = require('events');

// Common SNMP OIDs for MikroTik devices
const MIKROTIK_OIDS = {
  // System Information
  sysDescr: '1.3.6.1.2.1.1.1.0',
  sysUpTime: '1.3.6.1.2.1.1.3.0',
  sysName: '1.3.6.1.2.1.1.5.0',
  sysLocation: '1.3.6.1.2.1.1.6.0',
  
  // CPU Usage
  hrProcessorLoad: '1.3.6.1.2.1.25.3.3.1.2.1',
  
  // Memory Usage
  hrMemorySize: '1.3.6.1.2.1.25.2.2.0',
  hrStorageUsed: '1.3.6.1.2.1.25.2.3.1.6',
  hrStorageSize: '1.3.6.1.2.1.25.2.3.1.5',
  
  // Interface Statistics
  ifNumber: '1.3.6.1.2.1.2.1.0',
  ifDescr: '1.3.6.1.2.1.2.2.1.2',
  ifInOctets: '1.3.6.1.2.1.2.2.1.10',
  ifOutOctets: '1.3.6.1.2.1.2.2.1.16',
  ifInUcastPkts: '1.3.6.1.2.1.2.2.1.11',
  ifOutUcastPkts: '1.3.6.1.2.1.2.2.1.17',
  ifInErrors: '1.3.6.1.2.1.2.2.1.14',
  ifOutErrors: '1.3.6.1.2.1.2.2.1.20',
  ifOperStatus: '1.3.6.1.2.1.2.2.1.8',
  
  // MikroTik Specific
  mtxrHlTemperature: '1.3.6.1.4.1.14988.1.1.3.10.0',
  mtxrHlVoltage: '1.3.6.1.4.1.14988.1.1.3.8.0',
  mtxrHlCurrent: '1.3.6.1.4.1.14988.1.1.3.9.0',
  mtxrHlProcessorTemperature: '1.3.6.1.4.1.14988.1.1.3.11.0'
};

// Default collection intervals (in milliseconds)
const DEFAULT_INTERVALS = {
  fast: 60 * 1000,       // 1 minute
  standard: 5 * 60 * 1000,   // 5 minutes
  slow: 15 * 60 * 1000    // 15 minutes
};

// Metric definitions with OIDs and processing functions
const METRICS = {
  // System metrics - collected every standard interval
  system: {
    interval: 'standard',
    metrics: [
      {
        name: 'sysDescr',
        oid: MIKROTIK_OIDS.sysDescr,
        type: 'string',
        help: 'System description'
      },
      {
        name: 'sysUpTime', 
        oid: MIKROTIK_OIDS.sysUpTime,
        type: 'gauge',
        help: 'System uptime in timeticks (1/100s)',
        process: (value) => value / 100 // Convert to seconds
      },
      {
        name: 'sysName',
        oid: MIKROTIK_OIDS.sysName,
        type: 'string',
        help: 'System name'
      },
      {
        name: 'sysLocation',
        oid: MIKROTIK_OIDS.sysLocation,
        type: 'string',
        help: 'System location'
      }
    ]
  },
  
  // Resource metrics - collected every fast interval
  resources: {
    interval: 'fast',
    metrics: [
      {
        name: 'cpuUsage',
        oid: MIKROTIK_OIDS.hrProcessorLoad,
        type: 'gauge',
        help: 'CPU usage percentage',
        process: (value) => parseInt(value)
      },
      {
        name: 'memorySize',
        oid: MIKROTIK_OIDS.hrMemorySize,
        type: 'gauge',
        help: 'Total memory size in KB',
        process: (value) => parseInt(value)
      }
    ]
  },
  
  // Storage metrics - collected every fast interval
  storage: {
    interval: 'fast',
    isTable: true,
    baseOid: '1.3.6.1.2.1.25.2.3.1',
    indexColumn: 1,
    columns: [
      { 
        name: 'storageDescr', 
        column: 3, 
        type: 'string', 
        help: 'Storage description' 
      },
      { 
        name: 'storageAllocationUnits', 
        column: 4, 
        type: 'gauge', 
        help: 'Storage allocation units' 
      },
      { 
        name: 'storageSize', 
        column: 5, 
        type: 'gauge', 
        help: 'Storage size in allocation units' 
      },
      { 
        name: 'storageUsed', 
        column: 6, 
        type: 'gauge', 
        help: 'Storage used in allocation units' 
      }
    ],
    calculate: (row) => {
      if (row.storageSize > 0) {
        row.storageUsagePercent = (row.storageUsed / row.storageSize) * 100;
      } else {
        row.storageUsagePercent = 0;
      }
      return row;
    },
    filter: (row) => {
      try {
        return row.storageDescr && 
          (typeof row.storageDescr === 'string') &&
          (row.storageDescr.includes('disk') || 
           row.storageDescr.includes('flash') || 
           row.storageDescr.includes('storage') || 
           row.storageDescr.includes('drive'));
      } catch (error) {
        console.error(`Error in storage filter: ${error.message}`);
        return false;
      }
    }
  },
  
  // Temperature metrics - collected every standard interval
  temperature: {
    interval: 'standard',
    metrics: [
      {
        name: 'boardTemperature',
        oid: MIKROTIK_OIDS.mtxrHlTemperature,
        type: 'gauge',
        help: 'Board temperature in Celsius',
        process: (value) => value ? value / 10 : null
      },
      {
        name: 'cpuTemperature',
        oid: MIKROTIK_OIDS.mtxrHlProcessorTemperature,
        type: 'gauge',
        help: 'CPU temperature in Celsius',
        process: (value) => value ? value / 10 : null
      }
    ]
  },
  
  // Interface metrics - collected every fast interval
  interfaces: {
    interval: 'fast',
    isTable: true,
    baseOid: '1.3.6.1.2.1.2.2.1',
    indexColumn: 1,
    columns: [
      { 
        name: 'ifDescr', 
        column: 2, 
        type: 'string', 
        help: 'Interface description' 
      },
      { 
        name: 'ifType', 
        column: 3, 
        type: 'gauge', 
        help: 'Interface type' 
      },
      { 
        name: 'ifMtu', 
        column: 4, 
        type: 'gauge', 
        help: 'Interface MTU' 
      },
      { 
        name: 'ifSpeed', 
        column: 5, 
        type: 'gauge', 
        help: 'Interface speed in bits per second' 
      },
      { 
        name: 'ifOperStatus', 
        column: 8, 
        type: 'gauge', 
        help: 'Interface operational status (1=up, 2=down)' 
      },
      { 
        name: 'ifInOctets', 
        column: 10, 
        type: 'counter', 
        help: 'Incoming bytes' 
      },
      { 
        name: 'ifOutOctets', 
        column: 16, 
        type: 'counter', 
        help: 'Outgoing bytes' 
      },
      { 
        name: 'ifInErrors', 
        column: 14, 
        type: 'counter', 
        help: 'Incoming errors' 
      },
      { 
        name: 'ifOutErrors', 
        column: 20, 
        type: 'counter', 
        help: 'Outgoing errors' 
      }
    ],
    filter: (row) => row.ifOperStatus === 1 // Only include active interfaces
  }
};

/**
 * Creates an SNMP session for a device
 * @param {Object} device - The device configuration
 * @returns {Object} - SNMP session
 */
const createSession = (device) => {
  try {
    const options = {
      port: device.snmpPort || 161,
      retries: 1,
      timeout: device.snmpTimeout || 5000,
      version: device.snmpVersion === '1' ? snmp.Version1 : snmp.Version2c
    };
    
    return snmp.createSession(device.ipAddress, device.snmpCommunity, options);
  } catch (error) {
    console.error(`Error creating SNMP session for ${device.name}: ${error.message}`);
    throw error;
  }
};

/**
 * Collects scalar metrics from a device
 * @param {Object} session - SNMP session
 * @param {Array} metrics - Metrics configuration
 * @returns {Promise<Object>} - Collected metrics
 */
const collectScalarMetrics = async (session, metrics) => {
  return new Promise((resolve, reject) => {
    const oids = metrics.map(metric => metric.oid);
    
    session.get(oids, (error, varbinds) => {
      if (error) {
        reject(error);
        return;
      }
      
      const result = {};
      
      varbinds.forEach((vb, index) => {
        const metric = metrics[index];
        
        if (snmp.isVarbindError(vb)) {
          console.error(`Error collecting ${metric.name}: ${snmp.varbindError(vb)}`);
          result[metric.name] = null;
        } else {
          let value = vb.value;
          
          // Apply processing function if specified
          if (metric.process && typeof metric.process === 'function') {
            try {
              value = metric.process(value);
            } catch (e) {
              console.error(`Error processing ${metric.name}: ${e.message}`);
              value = null;
            }
          }
          
          // Handle non-serializable data types
          if (value instanceof Buffer) {
            value = value.toString('hex');
          } else if (typeof value === 'bigint') {
            value = Number(value);
          }
          
          result[metric.name] = value;
        }
      });
      
      resolve(result);
    });
  });
};

/**
 * Collects table metrics from a device
 * @param {Object} session - SNMP session
 * @param {Object} tableConfig - Table configuration
 * @returns {Promise<Array>} - Collected table rows
 */
const collectTableMetrics = async (session, tableConfig) => {
  return new Promise((resolve, reject) => {
    const baseOid = tableConfig.baseOid;
    const tableData = [];
    const rowsByIndex = {};
    
    // Walk the table
    session.subtree(baseOid, (varbinds) => {
      for (const vb of varbinds) {
        if (snmp.isVarbindError(vb)) {
          console.error(`Error in table walk: ${snmp.varbindError(vb)}`);
          continue;
        }
        
        // Parse OID to get the column and index
        const oidParts = vb.oid.split('.');
        const column = parseInt(oidParts[oidParts.length - 2]);
        const index = oidParts[oidParts.length - 1];
        
        // Initialize row if it doesn't exist
        if (!rowsByIndex[index]) {
          rowsByIndex[index] = { index };
        }
        
        // Find the corresponding column definition
        const columnDef = tableConfig.columns.find(col => col.column === column);
        if (columnDef) {
          let value = vb.value;
          
          // Apply processing function if specified
          if (columnDef.process && typeof columnDef.process === 'function') {
            try {
              value = columnDef.process(value);
            } catch (e) {
              console.error(`Error processing ${columnDef.name} for index ${index}: ${e.message}`);
              value = null;
            }
          }
          
          // Handle non-serializable data types
          if (value instanceof Buffer) {
            value = value.toString('hex');
          } else if (typeof value === 'bigint') {
            value = Number(value);
          }
          
          rowsByIndex[index][columnDef.name] = value;
        }
      }
    }, (error) => {
      if (error) {
        reject(error);
        return;
      }
      
      // Convert object to array and apply filters and calculations
      for (const index in rowsByIndex) {
        const row = rowsByIndex[index];
        
        // Apply calculations
        if (tableConfig.calculate && typeof tableConfig.calculate === 'function') {
          try {
            tableConfig.calculate(row);
          } catch (e) {
            console.error(`Error calculating values for index ${index}: ${e.message}`);
          }
        }
        
        // Apply filter if specified
        try {
          if (!tableConfig.filter || tableConfig.filter(row)) {
            tableData.push(row);
          }
        } catch (error) {
          console.error(`Error applying filter for row ${index}: ${error.message}`);
          // Include the row anyway in case of filter error
          tableData.push(row);
        }
      }

      // Sort table data by index to ensure consistent order
      tableData.sort((a, b) => a.index - b.index);
      
      resolve(tableData);
    });
  });
};

/**
 * Collects all metrics from a device
 * @param {Object} device - Device configuration
 * @param {Array} metricGroups - Metric groups to collect
 * @returns {Promise<Object>} - Collected metrics
 */
const collectMetrics = async (device, metricGroups = Object.keys(METRICS)) => {
  console.log(`Collecting metrics for device ${device.name} (${device.ipAddress})`);
  const session = createSession(device);
  const result = {
    deviceId: device._id,
    deviceName: device.name,
    ipAddress: device.ipAddress,
    timestamp: new Date(),
    metrics: {},
    summary: {
      cpuUsage: null,
      memoryUsage: null,
      diskUsage: null,
      temperature: null,
      uptime: null,
      status: 'ok',
      errors: []
    },
    responseTime: 0
  };
  
  try {
    // Process each metric group
    for (const groupName of metricGroups) {
      const group = METRICS[groupName];
      
      if (!group) {
        console.warn(`Unknown metric group: ${groupName}`);
        continue;
      }
      
      console.log(`Collecting ${groupName} metrics for ${device.name}`);
      
      if (group.isTable) {
        // Table metrics
        try {
          const tableData = await collectTableMetrics(session, group);
          result.metrics[groupName] = tableData;
        } catch (error) {
          console.error(`Error collecting ${groupName} table metrics: ${error.message}`);
          result.metrics[groupName] = [];
          result.summary.errors.push(`Failed to collect ${groupName} metrics: ${error.message}`);
          result.summary.status = 'partial';
        }
      } else {
        // Scalar metrics
        try {
          const scalarData = await collectScalarMetrics(session, group.metrics);
          result.metrics[groupName] = scalarData;
        } catch (error) {
          console.error(`Error collecting ${groupName} scalar metrics: ${error.message}`);
          result.metrics[groupName] = {};
          result.summary.errors.push(`Failed to collect ${groupName} metrics: ${error.message}`);
          result.summary.status = 'partial';
        }
      }
    }
    
    // Process the results to create a simplified view
    // Update summary values based on collected metrics
    result.summary.cpuUsage = result.metrics.resources?.cpuUsage ?? null;
    result.summary.temperature = result.metrics.temperature?.boardTemperature ?? 
                                result.metrics.temperature?.cpuTemperature ?? null;
    result.summary.uptime = result.metrics.system?.sysUpTime ?? null;
    
    // Calculate memory usage if we have both memorySize and storage table
    if (result.metrics.resources && result.metrics.resources.memorySize) {
      try {
        // First check if storage metrics exist
        if (!result.metrics.storage || !Array.isArray(result.metrics.storage) || result.metrics.storage.length === 0) {
          console.log(`No storage metrics found for device ${device.name}`);
        } else {
          // Safely find memory storage
          const memoryStorage = result.metrics.storage.find(storage => {
            // Extra safety checks
            if (!storage) return false;
            if (!storage.storageDescr) return false;
            if (typeof storage.storageDescr !== 'string') {
              console.log(`Non-string storageDescr found: ${typeof storage.storageDescr}`);
              return false;
            }
            
            const lowerDesc = storage.storageDescr.toLowerCase();
            return lowerDesc.includes('memory') || lowerDesc.includes('ram');
          });
          
          if (memoryStorage && typeof memoryStorage.storageUsagePercent === 'number') {
            result.summary.memoryUsage = memoryStorage.storageUsagePercent;
          } else {
            console.log(`No valid memory storage found for device ${device.name}`);
          }
        }
      } catch (error) {
        console.error(`Error calculating memory usage: ${error.message}`);
        result.summary.errors.push(`Failed to calculate memory usage: ${error.message}`);
      }
    }
    
    // Find disk storage
    try {
      // First check if storage metrics exist
      if (!result.metrics.storage || !Array.isArray(result.metrics.storage) || result.metrics.storage.length === 0) {
        console.log(`No storage metrics found for device ${device.name}`);
      } else {
        // Safely find disk storage
        const diskStorage = result.metrics.storage.find(storage => {
          // Extra safety checks
          if (!storage) return false;
          if (!storage.storageDescr) return false;
          if (typeof storage.storageDescr !== 'string') {
            console.log(`Non-string storageDescr found: ${typeof storage.storageDescr}`);
            return false;
          }
          
          const lowerDesc = storage.storageDescr.toLowerCase();
          return lowerDesc.includes('disk') || 
                 lowerDesc.includes('flash') ||
                 lowerDesc.includes('drive');
        });
        
        if (diskStorage && typeof diskStorage.storageUsagePercent === 'number') {
          result.summary.diskUsage = diskStorage.storageUsagePercent;
        } else {
          console.log(`No valid disk storage found for device ${device.name}`);
        }
      }
    } catch (error) {
      console.error(`Error calculating disk usage: ${error.message}`);
      result.summary.errors.push(`Failed to calculate disk usage: ${error.message}`);
    }
    
    return result;
  } finally {
    session.close();
  }
};

/**
 * Starts collecting metrics from a device at specified intervals
 * @param {Object} device - Device configuration
 * @param {Function} callback - Function to call with collected metrics
 * @returns {Object} - Control object with start/stop methods
 */
const startCollector = (device, callback) => {
  // Define variables at the beginning
  const timers = {};
  const collectors = {};
  
  // Define functions for start and stop
  const start = () => {
    console.log(`Starting metric collection for device ${device.name}`);
    
    for (const intervalType in collectors) {
      if (collectors[intervalType].length === 0) continue;
      
      const interval = DEFAULT_INTERVALS[intervalType];
      const groups = collectors[intervalType];
      
      console.log(`Setting up ${intervalType} collector (${interval}ms) for ${device.name}: ${groups.join(', ')}`);
      
      // Function to safely collect metrics and handle errors
      const safeCollect = async () => {
        try {
          const result = await collectMetrics(device, groups);
          console.log(`Collection completed for ${device.name} (${intervalType})`);
          
          // Check if there were errors
          if (result.summary.errors.length > 0) {
            console.warn(`Collection completed with ${result.summary.errors.length} errors for ${device.name}`);
          }
          
          callback(null, result);
        } catch (error) {
          console.error(`Error in collection for ${device.name} (${intervalType}): ${error.message}`);
          callback(error);
        }
      };
      
      // Immediately collect metrics when started
      safeCollect();
      
      // Schedule periodic collection
      timers[intervalType] = setInterval(safeCollect, interval);
    }
  };
  
  const stop = () => {
    console.log(`Stopping metric collection for device ${device.name}`);
    
    for (const intervalType in timers) {
      if (timers[intervalType]) {
        clearInterval(timers[intervalType]);
        timers[intervalType] = null;
      }
    }
  };
  
  // Create collectors for each interval type
  for (const intervalType in DEFAULT_INTERVALS) {
    collectors[intervalType] = [];
    
    // Group metrics by interval
    for (const [groupName, group] of Object.entries(METRICS)) {
      if (group.interval === intervalType) {
        collectors[intervalType].push(groupName);
      }
    }
  }
  
  // Return the collector object with start and stop methods
  const collectorObj = {
    start,
    stop
  };
  
  return collectorObj;
};

/**
 * Create SNMP session
 * @param {Object} config - SNMP configuration
 * @returns {Object} SNMP session
 */
const createSnmpSession = (config) => {
  const options = {
    port: config.snmpPort || 161,
    retries: 1,
    timeout: config.snmpTimeout || 5000,
    version: snmp.Version2c
  };

  if (config.snmpVersion === '1') {
    options.version = snmp.Version1;
  } else if (config.snmpVersion === '3') {
    options.version = snmp.Version3;
  }

  const community = config.snmpCommunity || 'public';
  return snmp.createSession(config.ipAddress, community, options);
};

/**
 * Get SNMP data from device using provided OIDs
 * @param {Object} device - Device object with SNMP configuration
 * @param {Array} oids - Array of OIDs to get
 * @returns {Promise<Object>} - Object with OID keys and values
 */
const getSnmpData = async (device, oids) => {
  return new Promise((resolve, reject) => {
    const session = createSnmpSession(device);
    
    session.get(oids, (error, varbinds) => {
      session.close();
      
      if (error) {
        console.error(`SNMP Error for ${device.name}: ${error.message}`);
        return reject(error);
      }
      
      const result = {};
      
      for (let i = 0; i < varbinds.length; i++) {
        if (snmp.isVarbindError(varbinds[i])) {
          console.error(`SNMP Error for OID ${oids[i]}: ${snmp.varbindError(varbinds[i])}`);
        } else {
          let value = varbinds[i].value;
          
          // Handle non-serializable data types
          if (value instanceof Buffer) {
            value = value.toString();
          } else if (typeof value === 'bigint') {
            value = Number(value);
          }
          
          result[oids[i]] = value;
        }
      }
      
      resolve(result);
    });
  });
};

/**
 * Get system information from device
 * @param {Object} device - Device object with SNMP configuration
 * @returns {Promise<Object>} - System information object
 */
const getSystemInfo = async (device) => {
  const oids = [
    MIKROTIK_OIDS.sysDescr,
    MIKROTIK_OIDS.sysUpTime,
    MIKROTIK_OIDS.sysName,
    MIKROTIK_OIDS.sysLocation
  ];
  
  try {
    const result = await getSnmpData(device, oids);
    
    // Convert uptime from timeticks (hundredths of a second) to seconds
    const uptimeTicks = result[MIKROTIK_OIDS.sysUpTime];
    const uptimeSeconds = uptimeTicks ? Math.floor(uptimeTicks / 100) : 0;
    
    return {
      description: result[MIKROTIK_OIDS.sysDescr] || 'Unknown',
      uptime: uptimeSeconds,
      name: result[MIKROTIK_OIDS.sysName] || 'Unknown',
      location: result[MIKROTIK_OIDS.sysLocation] || 'Unknown'
    };
  } catch (error) {
    console.error(`Failed to get system info for ${device.name}:`, error.message);
    throw error;
  }
};

/**
 * Get resource usage from device
 * @param {Object} device - Device object with SNMP configuration
 * @returns {Promise<Object>} - Resource usage object
 */
const getResourceUsage = async (device) => {
  try {
    // Get CPU usage
    const cpuResult = await getSnmpData(device, [MIKROTIK_OIDS.hrProcessorLoad]);
    const cpuUsage = cpuResult[MIKROTIK_OIDS.hrProcessorLoad] || 0;
    
    // Get memory info
    const memorySize = await getSnmpData(device, [MIKROTIK_OIDS.hrMemorySize]);
    const totalMemory = memorySize[MIKROTIK_OIDS.hrMemorySize] || 0;
    
    // Typically index 1 is physical memory on MikroTik
    const memoryUsed = await getSnmpData(device, [
      `${MIKROTIK_OIDS.hrStorageUsed}.1`,
      `${MIKROTIK_OIDS.hrStorageSize}.1`
    ]);
    
    const usedMem = memoryUsed[`${MIKROTIK_OIDS.hrStorageUsed}.1`] || 0;
    const totalMem = memoryUsed[`${MIKROTIK_OIDS.hrStorageSize}.1`] || totalMemory;
    
    const memoryUsage = totalMem > 0 ? Math.round((usedMem / totalMem) * 100) : 0;
    
    // Get disk usage - typically index 2 on MikroTik
    const diskUsage = await getSnmpData(device, [
      `${MIKROTIK_OIDS.hrStorageUsed}.2`,
      `${MIKROTIK_OIDS.hrStorageSize}.2`
    ]);
    
    const usedDisk = diskUsage[`${MIKROTIK_OIDS.hrStorageUsed}.2`] || 0;
    const totalDisk = diskUsage[`${MIKROTIK_OIDS.hrStorageSize}.2`] || 1;
    
    const diskUsagePercent = totalDisk > 0 ? Math.round((usedDisk / totalDisk) * 100) : 0;
    
    return {
      cpuUsage: parseInt(cpuUsage),
      memoryUsage: memoryUsage,
      diskUsage: diskUsagePercent,
      totalMemory: totalMem,
      usedMemory: usedMem,
      totalDisk: totalDisk,
      usedDisk: usedDisk
    };
  } catch (error) {
    console.error(`Failed to get resource usage for ${device.name}:`, error.message);
    throw error;
  }
};

/**
 * Get temperature information from device
 * @param {Object} device - Device object with SNMP configuration
 * @returns {Promise<Object>} - Temperature information object
 */
const getTemperature = async (device) => {
  const oids = [
    MIKROTIK_OIDS.mtxrHlTemperature,
    MIKROTIK_OIDS.mtxrHlProcessorTemperature
  ];
  
  try {
    const result = await getSnmpData(device, oids);
    
    // MikroTik returns temperature in tenths of degrees Celsius
    const boardTemp = result[MIKROTIK_OIDS.mtxrHlTemperature];
    const cpuTemp = result[MIKROTIK_OIDS.mtxrHlProcessorTemperature];
    
    return {
      boardTemperature: boardTemp ? (boardTemp / 10).toFixed(1) : null,
      cpuTemperature: cpuTemp ? (cpuTemp / 10).toFixed(1) : null
    };
  } catch (error) {
    console.error(`Failed to get temperature info for ${device.name}:`, error.message);
    throw error;
  }
};

/**
 * Get network interfaces information
 * @param {Object} device - Device object with SNMP configuration
 * @returns {Promise<Array>} - Array of interface objects
 */
const getNetworkInterfaces = async (device) => {
  try {
    // First get number of interfaces
    const ifNumberResult = await getSnmpData(device, [MIKROTIK_OIDS.ifNumber]);
    const ifNumber = ifNumberResult[MIKROTIK_OIDS.ifNumber];
    
    if (!ifNumber) {
      throw new Error('Could not determine number of interfaces');
    }
    
    console.log(`Device ${device.name} has ${ifNumber} interfaces`);
    
    // For each interface, get description, status, and traffic data
    const interfaces = [];
    
    for (let i = 1; i <= ifNumber; i++) {
      const ifOids = [
        `${MIKROTIK_OIDS.ifDescr}.${i}`,
        `${MIKROTIK_OIDS.ifOperStatus}.${i}`,
        `${MIKROTIK_OIDS.ifInOctets}.${i}`,
        `${MIKROTIK_OIDS.ifOutOctets}.${i}`,
        `${MIKROTIK_OIDS.ifInErrors}.${i}`,
        `${MIKROTIK_OIDS.ifOutErrors}.${i}`
      ];
      
      try {
        const ifData = await getSnmpData(device, ifOids);
        
        interfaces.push({
          index: i,
          ifDescr: ifData[`${MIKROTIK_OIDS.ifDescr}.${i}`] || `Interface ${i}`,
          ifOperStatus: parseInt(ifData[`${MIKROTIK_OIDS.ifOperStatus}.${i}`] || 0),
          ifInOctets: parseInt(ifData[`${MIKROTIK_OIDS.ifInOctets}.${i}`] || 0),
          ifOutOctets: parseInt(ifData[`${MIKROTIK_OIDS.ifOutOctets}.${i}`] || 0),
          ifInErrors: parseInt(ifData[`${MIKROTIK_OIDS.ifInErrors}.${i}`] || 0),
          ifOutErrors: parseInt(ifData[`${MIKROTIK_OIDS.ifOutErrors}.${i}`] || 0),
          status: parseInt(ifData[`${MIKROTIK_OIDS.ifOperStatus}.${i}`]) === 1 ? 'up' : 'down'
        });
      } catch (err) {
        console.error(`Error getting data for interface ${i}:`, err.message);
      }
    }
    
    return interfaces;
  } catch (error) {
    console.error('Error getting network interfaces:', error.message);
    throw error;
  }
};

/**
 * Get storage information
 * @param {Object} device - Device object with SNMP configuration
 * @returns {Promise<Array>} - Array of storage objects
 */
const getStorageInfo = async (device) => {
  try {
    // Get storage index
    const storageOids = [];
    for (let i = 1; i <= 10; i++) {  // Assume max 10 storage entries
      storageOids.push(`1.3.6.1.2.1.25.2.3.1.3.${i}`); // hrStorageDescr
    }
    
    const storageDescrResults = await getSnmpData(device, storageOids);
    const storageIndices = Object.keys(storageDescrResults).map(oid => {
      const parts = oid.split('.');
      return parseInt(parts[parts.length - 1]);
    });
    
    const storage = [];
    
    for (const index of storageIndices) {
      const detailOids = [
        `1.3.6.1.2.1.25.2.3.1.3.${index}`, // hrStorageDescr
        `1.3.6.1.2.1.25.2.3.1.4.${index}`, // hrStorageAllocationUnits
        `1.3.6.1.2.1.25.2.3.1.5.${index}`, // hrStorageSize
        `1.3.6.1.2.1.25.2.3.1.6.${index}`  // hrStorageUsed
      ];
      
      try {
        const storageData = await getSnmpData(device, detailOids);
        
        const descr = storageData[`1.3.6.1.2.1.25.2.3.1.3.${index}`];
        const allocationUnits = parseInt(storageData[`1.3.6.1.2.1.25.2.3.1.4.${index}`] || 0);
        const size = parseInt(storageData[`1.3.6.1.2.1.25.2.3.1.5.${index}`] || 0);
        const used = parseInt(storageData[`1.3.6.1.2.1.25.2.3.1.6.${index}`] || 0);
        
        // Skip non-physical storage
        if (descr && (descr.includes('Physical') || descr.includes('Fixed') || descr.includes('RAM'))) {
          const totalBytes = size * allocationUnits;
          const usedBytes = used * allocationUnits;
          const freeBytes = totalBytes - usedBytes;
          const usedPercent = totalBytes > 0 ? Math.round((usedBytes / totalBytes) * 100) : 0;
          
          storage.push({
            index,
            description: descr,
            sizeBytes: totalBytes,
            usedBytes,
            freeBytes,
            usedPercent,
            allocationUnits
          });
        }
      } catch (err) {
        console.error(`Error getting data for storage ${index}:`, err.message);
      }
    }
    
    return storage;
  } catch (error) {
    console.error('Error getting storage info:', error.message);
    throw error;
  }
};

/**
 * Get interface statistics
 * @param {Object} device - Device object with SNMP configuration
 * @param {Number} ifIndex - Interface index
 * @returns {Promise<Object>} - Interface statistics
 */
const getInterfaceStats = async (device, ifIndex) => {
  const oids = [
    `${MIKROTIK_OIDS.ifDescr}.${ifIndex}`,
    `${MIKROTIK_OIDS.ifInOctets}.${ifIndex}`,
    `${MIKROTIK_OIDS.ifOutOctets}.${ifIndex}`,
    `${MIKROTIK_OIDS.ifInUcastPkts}.${ifIndex}`,
    `${MIKROTIK_OIDS.ifOutUcastPkts}.${ifIndex}`,
    `${MIKROTIK_OIDS.ifInErrors}.${ifIndex}`,
    `${MIKROTIK_OIDS.ifOutErrors}.${ifIndex}`,
    `${MIKROTIK_OIDS.ifOperStatus}.${ifIndex}`
  ];
  
  try {
    const result = await getSnmpData(device, oids);
    
    return {
      description: result[`${MIKROTIK_OIDS.ifDescr}.${ifIndex}`] || `Interface ${ifIndex}`,
      inOctets: parseInt(result[`${MIKROTIK_OIDS.ifInOctets}.${ifIndex}`] || 0),
      outOctets: parseInt(result[`${MIKROTIK_OIDS.ifOutOctets}.${ifIndex}`] || 0),
      inPackets: parseInt(result[`${MIKROTIK_OIDS.ifInUcastPkts}.${ifIndex}`] || 0),
      outPackets: parseInt(result[`${MIKROTIK_OIDS.ifOutUcastPkts}.${ifIndex}`] || 0),
      inErrors: parseInt(result[`${MIKROTIK_OIDS.ifInErrors}.${ifIndex}`] || 0),
      outErrors: parseInt(result[`${MIKROTIK_OIDS.ifOutErrors}.${ifIndex}`] || 0),
      operStatus: parseInt(result[`${MIKROTIK_OIDS.ifOperStatus}.${ifIndex}`] || 0),
      status: parseInt(result[`${MIKROTIK_OIDS.ifOperStatus}.${ifIndex}`]) === 1 ? 'up' : 'down'
    };
  } catch (error) {
    console.error(`Failed to get stats for interface ${ifIndex}:`, error.message);
    throw error;
  }
};

/**
 * Test SNMP connectivity to a device
 * @param {Object} device - Device object with SNMP configuration
 * @returns {Promise<Object>} - Test results
 */
const testSnmpConnectivity = async (device) => {
  try {
    const startTime = Date.now();
    await getSnmpData(device, [MIKROTIK_OIDS.sysDescr]);
    const responseTime = Date.now() - startTime;
    
    return {
      success: true,
      responseTime,
      message: 'SNMP connectivity successful'
    };
  } catch (error) {
    return {
      success: false,
      responseTime: null,
      message: error.message
    };
  }
};

/**
 * Collector class for managing SNMP metrics collection with events
 * This enhanced collector provides event-based updates for real-time metrics
 */
class SnmpCollector extends EventEmitter {
  constructor(device, options = {}) {
    super();
    this.device = device;
    this.isRunning = false;
    this.intervals = {
      fast: options.fastInterval || DEFAULT_INTERVALS.fast,
      standard: options.standardInterval || DEFAULT_INTERVALS.standard,
      slow: options.slowInterval || DEFAULT_INTERVALS.slow
    };
    this.timers = {};
    this.lastMetrics = null;
    this.consecutiveErrors = 0;
    this.maxErrors = options.maxErrors || 5;
    this.stats = {
      totalCollections: 0,
      successfulCollections: 0,
      failedCollections: 0,
      lastCollectionTime: null,
      lastSuccessTime: null,
      lastError: null,
      uptime: 0,
      startTime: null
    };
  }

  /**
   * Start the collector
   */
  start() {
    if (this.isRunning) {
      return false;
    }

    this.isRunning = true;
    this.stats.startTime = Date.now();
    this.emit('start', { deviceId: this.device._id, deviceName: this.device.name });
    
    // Start collection immediately
    this._collect();
    
    // Schedule collections based on intervals
    this.timers.fast = setInterval(() => {
      this._collectByInterval('fast');
    }, this.intervals.fast);
    
    this.timers.standard = setInterval(() => {
      this._collectByInterval('standard');
    }, this.intervals.standard);
    
    this.timers.slow = setInterval(() => {
      this._collectByInterval('slow');
    }, this.intervals.slow);
    
    // Update uptime every minute
    this.timers.uptime = setInterval(() => {
      this.stats.uptime = Math.floor((Date.now() - this.stats.startTime) / 1000);
    }, 60000);
    
    return true;
  }

  /**
   * Stop the collector
   */
  stop() {
    if (!this.isRunning) {
      return false;
    }

    this.isRunning = false;
    
    // Clear all intervals
    Object.values(this.timers).forEach(timer => {
      clearInterval(timer);
    });
    
    this.timers = {};
    this.emit('stop', { 
      deviceId: this.device._id, 
      deviceName: this.device.name,
      stats: this.stats
    });
    
    return true;
  }

  /**
   * Get the current status of the collector
   */
  getStatus() {
    return {
      deviceId: this.device._id,
      deviceName: this.device.name,
      isRunning: this.isRunning,
      stats: this.stats,
      lastMetrics: this.lastMetrics ? {
        timestamp: this.lastMetrics.timestamp,
        summary: this.lastMetrics.summary
      } : null
    };
  }

  /**
   * Collect metrics immediately (one-time)
   */
  async collectNow() {
    return this._collect();
  }
  
  /**
   * Private method to collect metrics by interval type
   */
  _collectByInterval(intervalType) {
    if (!this.isRunning) return;
    
    Object.entries(METRICS).forEach(([metricGroup, config]) => {
      if (config.interval === intervalType) {
        this._collectMetricGroup(metricGroup);
      }
    });
  }
  
  /**
   * Private method to collect a specific metric group
   */
  async _collectMetricGroup(metricGroup) {
    if (!this.isRunning) return;
    
    try {
      // Implement specific collection logic for different metric groups
      // This is a placeholder for the actual implementation
      console.log(`Collecting ${metricGroup} metrics for ${this.device.name}`);
      
      // Update last metrics with the new data for this group
      if (!this.lastMetrics) {
        this.lastMetrics = {
          timestamp: new Date(),
          metrics: {},
          summary: {}
        };
      }
      
      // Emit the collected metrics for this group
      this.emit('metrics', {
        deviceId: this.device._id,
        deviceName: this.device.name,
        metricGroup,
        timestamp: new Date(),
        // Add the actual metrics here
      });
      
    } catch (error) {
      console.error(`Error collecting ${metricGroup} metrics for ${this.device.name}:`, error);
      this.emit('error', {
        deviceId: this.device._id,
        deviceName: this.device.name,
        metricGroup,
        error: error.message
      });
    }
  }

  /**
   * Private method to collect all metrics
   */
  async _collect() {
    if (!this.isRunning) return null;
    
    this.stats.totalCollections++;
    this.stats.lastCollectionTime = new Date();
    
    try {
      const metrics = await collectMetrics(this.device);
      this.lastMetrics = metrics;
      this.stats.successfulCollections++;
      this.stats.lastSuccessTime = new Date();
      this.consecutiveErrors = 0;
      
      this.emit('metrics', {
        deviceId: this.device._id,
        deviceName: this.device.name,
        timestamp: new Date(),
        metrics
      });
      
      return metrics;
    } catch (error) {
      this.stats.failedCollections++;
      this.stats.lastError = error.message;
      this.consecutiveErrors++;
      
      this.emit('error', {
        deviceId: this.device._id,
        deviceName: this.device.name,
        error: error.message,
        timestamp: new Date()
      });
      
      // Auto-stop after too many consecutive errors
      if (this.consecutiveErrors >= this.maxErrors) {
        console.error(`Too many errors (${this.consecutiveErrors}) for ${this.device.name}, stopping collector`);
        this.stop();
        
        this.emit('auto-stop', {
          deviceId: this.device._id,
          deviceName: this.device.name,
          reason: `Too many consecutive errors: ${this.consecutiveErrors}`,
          lastError: error.message
        });
      }
      
      return null;
    }
  }
}

/**
 * Create and start a collector for a device
 * @param {Object} device - Device object
 * @param {Function} callback - Callback function for metrics/errors
 * @param {Object} options - Collector options
 * @returns {SnmpCollector} - Collector instance
 */
const startCollector = (device, callback, options = {}) => {
  const collector = new SnmpCollector(device, options);
  
  if (callback) {
    collector.on('metrics', (data) => {
      callback(null, data.metrics);
    });
    
    collector.on('error', (data) => {
      callback(new Error(data.error));
    });
  }
  
  return collector;
};

module.exports = {
  MIKROTIK_OIDS,
  METRICS,
  DEFAULT_INTERVALS,
  createSnmpSession,
  getSnmpData,
  getSystemInfo,
  getResourceUsage,
  getInterfaceStats,
  getTemperature,
  getNetworkInterfaces,
  getStorageInfo,
  testSnmpConnectivity,
  collectMetrics,
  startCollector,
  SnmpCollector
};
